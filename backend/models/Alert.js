/**
 * Alert Model for IndraNav Adaptive Driving System
 * Manages safety alerts generated by the adaptive driving logic
 * Stores alert information for driver notification and analytics
 */

const mongoose = require('mongoose');

/**
 * Alert Schema Definition
 * Represents safety alerts triggered by the adaptive driving system
 * Based on real-time telemetry analysis and rule-based logic
 */
const alertSchema = new mongoose.Schema({
    // Reference to the driving session when this alert was generated
    // Links alerts to specific sessions for analysis and reporting
    sessionId: {
        type: String,
        required: [true, 'Session ID is required'],
        trim: true,
        index: true, // Index for session-based queries
        validate: {
            validator: function(v) {
                return /^[a-zA-Z0-9]{6,}$/.test(v);
            },
            message: 'Session ID must be alphanumeric and at least 6 characters long'
        }
    },

    // Timestamp when the alert was generated
    // Critical for correlation with telemetry data and driver responses
    timestamp: {
        type: Date,
        required: [true, 'Timestamp is required'],
        default: Date.now,
        index: true // Index for time-based queries and sorting
    },

    // Type of alert based on driving conditions and safety rules
    // Categorizes alerts for appropriate driver notification and response
    type: {
        type: String,
        required: [true, 'Alert type is required'],
        enum: {
            values: [
                'speed_warning',      // Speed exceeds safe limits
                'collision_warning',  // Obstacle too close for current speed
                'emergency_brake',    // Immediate braking required
                'lane_departure',     // Vehicle drifting from lane
                'weather_advisory',   // Weather conditions affecting safety
                'fatigue_detection',  // Driver showing signs of fatigue
                'maintenance_alert',  // Vehicle maintenance required
                'route_hazard',       // Known hazard on current route
                'traffic_congestion', // Heavy traffic conditions
                'low_visibility'      // Poor visibility conditions
            ],
            message: 'Alert type must be one of the predefined safety alert types'
        },
        lowercase: true,
        trim: true,
        index: true // Index for alert type analysis
    },

    // Whether the alert was actually triggered/sent to the driver
    // Allows for alert generation without immediate notification
    triggered: {
        type: Boolean,
        required: [true, 'Triggered status is required'],
        default: false,
        index: true // Index for filtering triggered/untriggered alerts
    },

    // Severity level of the alert (derived from type and conditions)
    severity: {
        type: String,
        enum: {
            values: ['low', 'medium', 'high', 'critical'],
            message: 'Severity must be low, medium, high, or critical'
        },
        default: 'medium',
        index: true
    },

    // Additional context or details about the alert
    message: {
        type: String,
        trim: true,
        maxlength: [500, 'Alert message cannot exceed 500 characters']
    },

    // Telemetry data that triggered this alert (snapshot)
    triggerData: {
        speed: {
            type: Number,
            min: 0
        },
        obstacleDistance: {
            type: Number,
            min: 0
        },
        gps: {
            lat: {
                type: Number,
                min: -90,
                max: 90
            },
            lng: {
                type: Number,
                min: -180,
                max: 180
            }
        }
    },

    // Whether the alert has been acknowledged by the driver
    acknowledged: {
        type: Boolean,
        default: false,
        index: true
    },

    // Timestamp when the alert was acknowledged
    acknowledgedAt: {
        type: Date,
        default: null
    }
}, {
    // Automatically add createdAt and updatedAt timestamps
    timestamps: true,
    
    // Optimize JSON output
    toJSON: {
        transform: function(doc, ret) {
            delete ret.__v;
            return ret;
        }
    }
});

/**
 * Virtual property to calculate alert age
 * Returns the time elapsed since the alert was generated
 */
alertSchema.virtual('age').get(function() {
    return Date.now() - this.timestamp.getTime();
});

/**
 * Virtual property to get alert status
 * Returns comprehensive status including acknowledgment and age
 */
alertSchema.virtual('status').get(function() {
    if (this.acknowledged) {
        return 'acknowledged';
    } else if (this.triggered) {
        return this.age > 300000 ? 'expired' : 'active'; // 5 minutes timeout
    } else {
        return 'pending';
    }
});

/**
 * Instance method to trigger the alert
 * Marks the alert as triggered and sets appropriate severity
 */
alertSchema.methods.trigger = function() {
    this.triggered = true;
    
    // Auto-set severity based on alert type if not already set
    if (this.severity === 'medium') {
        const criticalTypes = ['emergency_brake', 'collision_warning'];
        const highTypes = ['speed_warning', 'lane_departure', 'low_visibility'];
        const lowTypes = ['maintenance_alert', 'route_hazard'];
        
        if (criticalTypes.includes(this.type)) {
            this.severity = 'critical';
        } else if (highTypes.includes(this.type)) {
            this.severity = 'high';
        } else if (lowTypes.includes(this.type)) {
            this.severity = 'low';
        }
    }
    
    return this.save();
};

/**
 * Instance method to acknowledge the alert
 * Marks the alert as acknowledged by the driver
 */
alertSchema.methods.acknowledge = function() {
    this.acknowledged = true;
    this.acknowledgedAt = new Date();
    return this.save();
};

/**
 * Static method to find alerts by session
 * Returns alerts for a specific session, sorted by timestamp
 */
alertSchema.statics.findBySession = function(sessionId, includeUntriggered = false) {
    const query = { sessionId };
    if (!includeUntriggered) {
        query.triggered = true;
    }
    
    return this.find(query).sort({ timestamp: -1 });
};

/**
 * Static method to find active alerts
 * Returns alerts that are triggered but not yet acknowledged
 */
alertSchema.statics.findActive = function() {
    return this.find({
        triggered: true,
        acknowledged: false
    }).sort({ severity: -1, timestamp: -1 });
};

/**
 * Static method to find critical alerts
 * Returns high-priority alerts that need immediate attention
 */
alertSchema.statics.findCritical = function() {
    return this.find({
        severity: 'critical',
        triggered: true,
        acknowledged: false
    }).sort({ timestamp: -1 });
};

/**
 * Static method to get alert statistics for a session
 * Returns aggregated alert data for analytics
 */
alertSchema.statics.getSessionAlertStats = function(sessionId) {
    return this.aggregate([
        { $match: { sessionId, triggered: true } },
        {
            $group: {
                _id: '$sessionId',
                totalAlerts: { $sum: 1 },
                alertsByType: {
                    $push: {
                        type: '$type',
                        severity: '$severity',
                        timestamp: '$timestamp'
                    }
                },
                averageResponseTime: {
                    $avg: {
                        $subtract: ['$acknowledgedAt', '$timestamp']
                    }
                },
                criticalAlerts: {
                    $sum: {
                        $cond: [{ $eq: ['$severity', 'critical'] }, 1, 0]
                    }
                },
                acknowledgedAlerts: {
                    $sum: {
                        $cond: ['$acknowledged', 1, 0]
                    }
                }
            }
        }
    ]);
};

/**
 * Pre-save middleware to set default message based on alert type
 * Provides human-readable messages if not explicitly set
 */
alertSchema.pre('save', function(next) {
    if (!this.message) {
        const defaultMessages = {
            'speed_warning': 'Vehicle speed exceeds safe limits for current conditions',
            'collision_warning': 'Obstacle detected - maintain safe distance',
            'emergency_brake': 'EMERGENCY: Immediate braking required',
            'lane_departure': 'Vehicle departing from current lane',
            'weather_advisory': 'Weather conditions may affect driving safety',
            'fatigue_detection': 'Driver fatigue detected - consider taking a break',
            'maintenance_alert': 'Vehicle maintenance attention required',
            'route_hazard': 'Known hazard detected on current route',
            'traffic_congestion': 'Heavy traffic conditions ahead',
            'low_visibility': 'Poor visibility conditions - reduce speed'
        };
        
        this.message = defaultMessages[this.type] || 'Safety alert triggered';
    }
    next();
});

/**
 * Compound indexes for optimized queries
 */

// Index for session-based alert queries
alertSchema.index({ sessionId: 1, timestamp: -1 });

// Index for active alert monitoring
alertSchema.index({ triggered: 1, acknowledged: 1, severity: -1 });

// Index for alert type analysis
alertSchema.index({ type: 1, severity: 1 });

// Export the Alert model
module.exports = mongoose.model('Alert', alertSchema);
