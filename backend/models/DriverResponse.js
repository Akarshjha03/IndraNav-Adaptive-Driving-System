/**
 * DriverResponse Model for IndraNav Adaptive Driving System
 * Tracks driver responses to safety alerts for behavior analysis
 * Critical for measuring driver reaction times and adaptive system effectiveness
 */

const mongoose = require('mongoose');

/**
 * DriverResponse Schema Definition
 * Records how drivers respond to safety alerts generated by the system
 * Used for performance analytics and adaptive behavior learning
 */
const driverResponseSchema = new mongoose.Schema({
    // Reference to the driving session when this response occurred
    // Links responses to specific sessions for comprehensive analysis
    sessionId: {
        type: String,
        required: [true, 'Session ID is required'],
        trim: true,
        index: true, // Index for session-based queries
        validate: {
            validator: function(v) {
                return /^[a-zA-Z0-9]{6,}$/.test(v);
            },
            message: 'Session ID must be alphanumeric and at least 6 characters long'
        }
    },

    // Reference to the specific alert that triggered this response
    // ObjectId reference to the Alert model for relational data integrity
    alertId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'Alert', // Reference to Alert model
        required: [true, 'Alert ID is required'],
        index: true, // Index for alert-response correlation queries
        validate: {
            validator: function(v) {
                return mongoose.Types.ObjectId.isValid(v);
            },
            message: 'Alert ID must be a valid ObjectId'
        }
    },

    // Timestamp when the driver response was recorded
    // Used to calculate reaction times and response patterns
    timestamp: {
        type: Date,
        required: [true, 'Response timestamp is required'],
        default: Date.now,
        index: true // Index for time-based analysis
    },

    // Type of action taken by the driver in response to the alert
    // Categorizes driver behavior for analysis and learning
    actionTaken: {
        type: String,
        required: [true, 'Action taken is required'],
        enum: {
            values: [
                'brake_applied',      // Driver applied brakes
                'speed_reduced',      // Driver reduced speed gradually
                'lane_change',        // Driver changed lanes
                'steering_corrected', // Driver adjusted steering
                'hazards_activated',  // Driver activated hazard lights
                'stopped_vehicle',    // Driver stopped the vehicle
                'acknowledged_only',  // Driver only acknowledged alert
                'no_action',          // No physical action taken
                'accelerated',        // Driver accelerated (unexpected response)
                'ignored_alert',      // Driver ignored the alert completely
                'manual_override',    // Driver overrode automatic systems
                'emergency_maneuver'  // Driver performed emergency maneuver
            ],
            message: 'Action taken must be one of the predefined response types'
        },
        lowercase: true,
        trim: true,
        index: true // Index for response type analysis
    },

    // Time taken by driver to respond to the alert (in milliseconds)
    // Critical metric for evaluating driver attention and system effectiveness
    reactionTime: {
        type: Number,
        required: [true, 'Reaction time is required'],
        min: [0, 'Reaction time cannot be negative'],
        max: [30000, 'Reaction time cannot exceed 30 seconds'], // Reasonable upper limit
        validate: {
            validator: function(v) {
                return typeof v === 'number' && !isNaN(v) && v >= 0;
            },
            message: 'Reaction time must be a valid positive number in milliseconds'
        }
    },

    // Effectiveness rating of the response (calculated or manually assessed)
    effectiveness: {
        type: String,
        enum: {
            values: ['excellent', 'good', 'adequate', 'poor', 'dangerous'],
            message: 'Effectiveness must be excellent, good, adequate, poor, or dangerous'
        },
        default: 'adequate',
        index: true
    },

    // Additional context about the response
    notes: {
        type: String,
        trim: true,
        maxlength: [500, 'Notes cannot exceed 500 characters']
    },

    // Whether the response was appropriate for the alert type
    appropriate: {
        type: Boolean,
        default: true,
        index: true
    },

    // Vehicle telemetry at the time of response (snapshot)
    responseContext: {
        speed: {
            type: Number,
            min: 0
        },
        obstacleDistance: {
            type: Number,
            min: 0
        },
        gps: {
            lat: {
                type: Number,
                min: -90,
                max: 90
            },
            lng: {
                type: Number,
                min: -180,
                max: 180
            }
        }
    }
}, {
    // Automatically add createdAt and updatedAt timestamps
    timestamps: true,
    
    // Optimize JSON output
    toJSON: {
        transform: function(doc, ret) {
            delete ret.__v;
            return ret;
        }
    }
});

/**
 * Virtual property to convert reaction time to seconds
 * Provides more readable reaction time in seconds
 */
driverResponseSchema.virtual('reactionTimeSeconds').get(function() {
    return this.reactionTime / 1000;
});

/**
 * Virtual property to categorize reaction time performance
 * Returns performance category based on reaction time benchmarks
 */
driverResponseSchema.virtual('reactionTimeCategory').get(function() {
    const timeMs = this.reactionTime;
    
    if (timeMs <= 1000) {
        return 'excellent';    // Under 1 second
    } else if (timeMs <= 2000) {
        return 'good';         // 1-2 seconds
    } else if (timeMs <= 5000) {
        return 'adequate';     // 2-5 seconds
    } else if (timeMs <= 10000) {
        return 'poor';         // 5-10 seconds
    } else {
        return 'dangerous';    // Over 10 seconds
    }
});

/**
 * Instance method to evaluate response appropriateness
 * Assesses if the action taken was appropriate for the alert type
 */
driverResponseSchema.methods.evaluateAppropriate = async function() {
    // Populate the alert to access its type
    await this.populate('alertId');
    
    const alertType = this.alertId.type;
    const action = this.actionTaken;
    
    // Define appropriate actions for each alert type
    const appropriateActions = {
        'speed_warning': ['brake_applied', 'speed_reduced'],
        'collision_warning': ['brake_applied', 'speed_reduced', 'lane_change', 'steering_corrected'],
        'emergency_brake': ['brake_applied', 'stopped_vehicle', 'emergency_maneuver'],
        'lane_departure': ['steering_corrected', 'lane_change'],
        'weather_advisory': ['speed_reduced', 'hazards_activated'],
        'fatigue_detection': ['stopped_vehicle', 'acknowledged_only'],
        'maintenance_alert': ['acknowledged_only', 'stopped_vehicle'],
        'route_hazard': ['speed_reduced', 'lane_change', 'steering_corrected'],
        'traffic_congestion': ['speed_reduced', 'brake_applied'],
        'low_visibility': ['speed_reduced', 'hazards_activated']
    };
    
    this.appropriate = appropriateActions[alertType]?.includes(action) || false;
    return this.save();
};

/**
 * Static method to find responses by session
 * Returns driver responses for a specific session
 */
driverResponseSchema.statics.findBySession = function(sessionId) {
    return this.find({ sessionId })
               .populate('alertId', 'type severity timestamp')
               .sort({ timestamp: -1 });
};

/**
 * Static method to find responses by alert
 * Returns all responses to a specific alert
 */
driverResponseSchema.statics.findByAlert = function(alertId) {
    return this.find({ alertId })
               .populate('alertId', 'type severity timestamp')
               .sort({ timestamp: 1 });
};

/**
 * Static method to calculate average reaction time by action type
 * Returns analytics data for performance assessment
 */
driverResponseSchema.statics.getReactionTimeStats = function(sessionId = null) {
    const matchStage = sessionId ? { sessionId } : {};
    
    return this.aggregate([
        { $match: matchStage },
        {
            $group: {
                _id: '$actionTaken',
                avgReactionTime: { $avg: '$reactionTime' },
                minReactionTime: { $min: '$reactionTime' },
                maxReactionTime: { $max: '$reactionTime' },
                responseCount: { $sum: 1 }
            }
        },
        { $sort: { avgReactionTime: 1 } }
    ]);
};

/**
 * Static method to get driver performance summary
 * Returns comprehensive performance metrics for analysis
 */
driverResponseSchema.statics.getPerformanceSummary = function(sessionId) {
    return this.aggregate([
        { $match: { sessionId } },
        {
            $group: {
                _id: '$sessionId',
                totalResponses: { $sum: 1 },
                avgReactionTime: { $avg: '$reactionTime' },
                appropriateResponses: {
                    $sum: { $cond: ['$appropriate', 1, 0] }
                },
                excellentResponses: {
                    $sum: { $cond: [{ $lte: ['$reactionTime', 1000] }, 1, 0] }
                },
                poorResponses: {
                    $sum: { $cond: [{ $gt: ['$reactionTime', 5000] }, 1, 0] }
                },
                responseTypes: {
                    $push: '$actionTaken'
                }
            }
        },
        {
            $addFields: {
                appropriatenessRate: {
                    $multiply: [
                        { $divide: ['$appropriateResponses', '$totalResponses'] },
                        100
                    ]
                },
                excellenceRate: {
                    $multiply: [
                        { $divide: ['$excellentResponses', '$totalResponses'] },
                        100
                    ]
                }
            }
        }
    ]);
};

/**
 * Pre-save middleware to auto-calculate effectiveness
 * Sets effectiveness rating based on reaction time and appropriateness
 */
driverResponseSchema.pre('save', function(next) {
    // Auto-calculate effectiveness if not explicitly set
    if (this.effectiveness === 'adequate') {
        const timeCategory = this.reactionTimeCategory;
        
        if (!this.appropriate) {
            this.effectiveness = 'dangerous';
        } else if (timeCategory === 'excellent') {
            this.effectiveness = 'excellent';
        } else if (timeCategory === 'good') {
            this.effectiveness = 'good';
        } else if (timeCategory === 'poor' || timeCategory === 'dangerous') {
            this.effectiveness = 'poor';
        }
        // Keep 'adequate' for timeCategory === 'adequate'
    }
    
    next();
});

/**
 * Compound indexes for optimized queries
 */

// Index for session-based response analysis
driverResponseSchema.index({ sessionId: 1, timestamp: -1 });

// Index for alert-response correlation
driverResponseSchema.index({ alertId: 1, reactionTime: 1 });

// Index for performance analysis
driverResponseSchema.index({ actionTaken: 1, reactionTime: 1 });

// Index for effectiveness analysis
driverResponseSchema.index({ effectiveness: 1, appropriate: 1 });

// Export the DriverResponse model
module.exports = mongoose.model('DriverResponse', driverResponseSchema);
