/**
 * Alerts Router for IndraNav Adaptive Driving System
 * Handles safety alert creation and management
 * Processes hazard alerts generated by adaptive driving logic
 */

const express = require('express');
const mongoose = require('mongoose');
const router = express.Router();

// Import models
const Alert = mongoose.model('Alert');
const Session = mongoose.model('Session');
const TelemetryLog = mongoose.model('TelemetryLog');

// ==============================================
// ALERT CREATION ENDPOINTS
// ==============================================

/**
 * POST /api/alerts
 * Creates a new safety alert for the adaptive driving system
 * 
 * Expected body:
 * {
 *   "sessionId": "session_123",              // Required: Session identifier
 *   "type": "collision_warning",             // Required: Alert type
 *   "triggered": true,                       // Optional: Whether alert was sent to driver (default: false)
 *   "severity": "high",                      // Optional: low, medium, high, critical (auto-calculated if not provided)
 *   "message": "Custom alert message",       // Optional: Custom message (auto-generated if not provided)
 *   "triggerData": {                         // Optional: Telemetry snapshot that caused alert
 *     "speed": 95.5,
 *     "obstacleDistance": 25.0,
 *     "gps": { "lat": 40.7128, "lng": -74.0060 }
 *   },
 *   "timestamp": "2024-01-01T12:00:00Z"     // Optional: Auto-generated if not provided
 * }
 */
router.post('/', async (req, res) => {
    try {
        console.log('üö® Creating new safety alert...');
        
        const { 
            sessionId, 
            type, 
            triggered = false, 
            severity, 
            message, 
            triggerData, 
            timestamp 
        } = req.body;
        
        // Validate required fields
        if (!sessionId) {
            return res.status(400).json({
                status: 'error',
                message: 'sessionId is required',
                field: 'sessionId'
            });
        }
        
        if (!type) {
            return res.status(400).json({
                status: 'error',
                message: 'Alert type is required',
                field: 'type',
                validTypes: [
                    'speed_warning', 'collision_warning', 'emergency_brake',
                    'lane_departure', 'weather_advisory', 'fatigue_detection',
                    'maintenance_alert', 'route_hazard', 'traffic_congestion', 'low_visibility'
                ]
            });
        }
        
        // Verify session exists
        const sessionExists = await Session.findOne({ sessionId });
        if (!sessionExists) {
            return res.status(404).json({
                status: 'error',
                message: `Session '${sessionId}' not found`,
                hint: 'Make sure the session exists before creating alerts'
            });
        }
        
        // Create alert data
        const alertData = {
            sessionId,
            type: type.toLowerCase().trim(),
            triggered,
            triggerData: triggerData || {}
        };
        
        // Add optional fields if provided
        if (severity) {
            alertData.severity = severity.toLowerCase().trim();
        }
        
        if (message) {
            alertData.message = message.trim();
        }
        
        if (timestamp) {
            alertData.timestamp = new Date(timestamp);
        }
        
        // Create new alert
        const newAlert = new Alert(alertData);
        
        // Trigger the alert if requested (this also auto-sets severity)
        if (triggered) {
            await newAlert.trigger();
        } else {
            await newAlert.save();
        }
        
        // Fetch latest telemetry for context if not provided
        let contextualInfo = {};
        if (!triggerData) {
            try {
                const latestTelemetry = await TelemetryLog.findOne({ sessionId })
                                                         .sort({ timestamp: -1 })
                                                         .limit(1)
                                                         .lean();
                if (latestTelemetry) {
                    contextualInfo.recentTelemetry = {
                        speed: latestTelemetry.speed,
                        obstacleDistance: latestTelemetry.obstacleDistance,
                        timestamp: latestTelemetry.timestamp
                    };
                }
            } catch (error) {
                console.warn('Warning: Could not fetch contextual telemetry:', error.message);
            }
        }
        
        console.log(`‚úÖ Alert created: ${newAlert.type} for session: ${sessionId} | Triggered: ${triggered}`);
        
        res.status(201).json({
            status: 'success',
            message: 'Safety alert created successfully',
            data: {
                alert: newAlert,
                alertStatus: newAlert.status,
                alertAge: newAlert.age,
                contextualInfo,
                creationTimestamp: new Date().toISOString()
            }
        });
        
        // Log alert for monitoring and analytics
        if (newAlert.severity === 'critical') {
            console.warn(`üî¥ CRITICAL ALERT: ${newAlert.type} in session ${sessionId}`);
        }
        
    } catch (error) {
        console.error('‚ùå Error creating alert:', error);
        
        // Handle validation errors
        if (error.name === 'ValidationError') {
            const validationErrors = Object.values(error.errors).map(err => ({
                field: err.path,
                message: err.message,
                value: err.value
            }));
            
            return res.status(400).json({
                status: 'error',
                message: 'Alert validation failed',
                errors: validationErrors
            });
        }
        
        res.status(500).json({
            status: 'error',
            message: 'Failed to create alert',
            error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
});

// ==============================================
// ALERT MANAGEMENT ENDPOINTS
// ==============================================

/**
 * PUT /api/alerts/:id/acknowledge
 * Acknowledges an alert (marks it as seen/handled by driver)
 * 
 * Expected body:
 * {
 *   "acknowledgedAt": "2024-01-01T12:05:00Z"  // Optional: Custom acknowledgment time
 * }
 */
router.put('/:id/acknowledge', async (req, res) => {
    try {
        const alertId = req.params.id;
        const { acknowledgedAt } = req.body;
        
        console.log(`‚úã Acknowledging alert: ${alertId}`);
        
        // Validate ObjectId
        if (!mongoose.Types.ObjectId.isValid(alertId)) {
            return res.status(400).json({
                status: 'error',
                message: 'Invalid alert ID format',
                field: 'alertId'
            });
        }
        
        // Find the alert
        const alert = await Alert.findById(alertId);
        
        if (!alert) {
            return res.status(404).json({
                status: 'error',
                message: `Alert with ID '${alertId}' not found`
            });
        }
        
        // Check if already acknowledged
        if (alert.acknowledged) {
            return res.status(400).json({
                status: 'error',
                message: 'Alert has already been acknowledged',
                data: {
                    alertId: alert._id,
                    acknowledgedAt: alert.acknowledgedAt,
                    originalTimestamp: alert.timestamp
                }
            });
        }
        
        // Acknowledge the alert
        if (acknowledgedAt) {
            alert.acknowledgedAt = new Date(acknowledgedAt);
            alert.acknowledged = true;
            await alert.save();
        } else {
            await alert.acknowledge(); // Use the instance method
        }
        
        // Calculate response time
        const responseTime = alert.acknowledgedAt.getTime() - alert.timestamp.getTime();
        
        console.log(`‚úÖ Alert acknowledged: ${alertId} | Response time: ${responseTime}ms`);
        
        res.status(200).json({
            status: 'success',
            message: 'Alert acknowledged successfully',
            data: {
                alert: alert,
                responseTime,
                responseTimeSeconds: (responseTime / 1000).toFixed(2),
                alertStatus: alert.status
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error acknowledging alert:', error);
        
        res.status(500).json({
            status: 'error',
            message: 'Failed to acknowledge alert',
            error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
});

/**
 * GET /api/alerts/active
 * Retrieves all active (triggered but not acknowledged) alerts
 * Useful for real-time monitoring dashboards
 */
router.get('/active', async (req, res) => {
    try {
        const limit = Math.min(parseInt(req.query.limit) || 50, 200); // Max 200 alerts
        const severity = req.query.severity; // Optional severity filter
        
        console.log('üîç Retrieving active alerts...');
        
        // Build query
        let query = {
            triggered: true,
            acknowledged: false
        };
        
        if (severity) {
            query.severity = severity.toLowerCase();
        }
        
        // Get active alerts with session context
        const activeAlerts = await Alert.find(query)
                                       .sort({ severity: -1, timestamp: -1 })
                                       .limit(limit)
                                       .populate('sessionId', 'weather roadType startTime', 'Session')
                                       .lean();
        
        // Add age and urgency info to each alert
        const enrichedAlerts = activeAlerts.map(alert => {
            const age = Date.now() - new Date(alert.timestamp).getTime();
            const ageMinutes = Math.floor(age / (1000 * 60));
            
            return {
                ...alert,
                age,
                ageMinutes,
                urgency: calculateAlertUrgency(alert.severity, age)
            };
        });
        
        // Group by severity for better organization
        const alertsBySeverity = {
            critical: enrichedAlerts.filter(a => a.severity === 'critical'),
            high: enrichedAlerts.filter(a => a.severity === 'high'),
            medium: enrichedAlerts.filter(a => a.severity === 'medium'),
            low: enrichedAlerts.filter(a => a.severity === 'low')
        };
        
        console.log(`‚úÖ Retrieved ${enrichedAlerts.length} active alerts`);
        
        res.status(200).json({
            status: 'success',
            message: 'Active alerts retrieved successfully',
            data: {
                totalActiveAlerts: enrichedAlerts.length,
                alerts: enrichedAlerts,
                alertsBySeverity,
                retrievalTimestamp: new Date().toISOString()
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error retrieving active alerts:', error);
        
        res.status(500).json({
            status: 'error',
            message: 'Failed to retrieve active alerts',
            error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
});

/**
 * GET /api/alerts/session/:sessionId
 * Retrieves all alerts for a specific session
 */
router.get('/session/:sessionId', async (req, res) => {
    try {
        const sessionId = req.params.sessionId;
        const includeUntriggered = req.query.includeUntriggered === 'true';
        const limit = Math.min(parseInt(req.query.limit) || 100, 500);
        
        console.log(`üîç Retrieving alerts for session: ${sessionId}`);
        
        // Verify session exists
        const sessionExists = await Session.findOne({ sessionId });
        if (!sessionExists) {
            return res.status(404).json({
                status: 'error',
                message: `Session '${sessionId}' not found`
            });
        }
        
        // Get session alerts using the static method
        const alerts = await Alert.findBySession(sessionId, includeUntriggered);
        
        // Calculate alert statistics
        const stats = {
            totalAlerts: alerts.length,
            triggeredAlerts: alerts.filter(a => a.triggered).length,
            acknowledgedAlerts: alerts.filter(a => a.acknowledged).length,
            alertsByType: {},
            alertsBySeverity: {}
        };
        
        alerts.forEach(alert => {
            // Count by type
            stats.alertsByType[alert.type] = (stats.alertsByType[alert.type] || 0) + 1;
            
            // Count by severity
            stats.alertsBySeverity[alert.severity] = (stats.alertsBySeverity[alert.severity] || 0) + 1;
        });
        
        console.log(`‚úÖ Retrieved ${alerts.length} alerts for session: ${sessionId}`);
        
        res.status(200).json({
            status: 'success',
            message: `Alerts retrieved for session ${sessionId}`,
            data: {
                sessionId,
                alerts: alerts.slice(0, limit), // Apply limit
                statistics: stats,
                session: {
                    sessionId: sessionExists.sessionId,
                    startTime: sessionExists.startTime,
                    endTime: sessionExists.endTime,
                    status: sessionExists.status
                }
            }
        });
        
    } catch (error) {
        console.error('‚ùå Error retrieving session alerts:', error);
        
        res.status(500).json({
            status: 'error',
            message: 'Failed to retrieve session alerts',
            error: process.env.NODE_ENV === 'development' ? error.message : 'Internal server error'
        });
    }
});

// ==============================================
// HELPER FUNCTIONS
// ==============================================

/**
 * Calculate alert urgency based on severity and age
 * Returns: 'immediate', 'high', 'medium', 'low'
 */
function calculateAlertUrgency(severity, ageMs) {
    const ageMinutes = ageMs / (1000 * 60);
    
    if (severity === 'critical') {
        return ageMinutes > 5 ? 'immediate' : 'immediate';
    } else if (severity === 'high') {
        return ageMinutes > 10 ? 'high' : 'high';
    } else if (severity === 'medium') {
        return ageMinutes > 30 ? 'medium' : 'medium';
    } else {
        return 'low';
    }
}

// Export the router
module.exports = router;
